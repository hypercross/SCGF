Fiber = require('fibers')
Parse = require('minimist')
logger = require './logger'
_ = require('lodash')

model = @

Function::property = (prop, desc) ->
	Object.defineProperty @prototype, prop, desc

Function::type_property = (prop) ->
	Object.defineProperty @prototype, prop,
		get : -> @Type.props[prop]
		set : (val) -> @Type.props[prop] = val

class EntityRegistry
	constructor: (@game)->
		@fallback = model.Entity

	addPrototype: (proto)->
		@[proto.name] = proto

	addFallback: (@fallback)->

	spawnEntityByType: (type)->
		c = @[type];
		if c
			return new c @
		return new @fallback @

class @Entity
	constructor: (@registry) ->
		@id = _.uniqueId()
		@_ondelete = []

	setComponent: (type) ->
		type.setEntity @
		@_ondelete.push(type)
		return @

	remove: ()->
		_.forEach @_ondelete, (one)-> one.onDelete()

	spawnChild: (childType, name)->
		e = new childType @registry
		e.addToParent @
		e.Type.props.name = name if name
		return e

	addToParent: (parent)->
		parent = @game().root if not parent
		@Owned.by = parent
		@Peer.appendTo (_.last parent.children())
		@Peer.claim();
		@Owned.claim();
		return @

	removeFromParent: ()->
		parent = @Owned.by
		if parent
			_.remove parent.Owner.of, (one)=>one == @
		@Peer.prev.Peer.next = @Peer.next
		@Peer.next.Peer.prev = @Peer.prev
		@Owned.by = null

	isParentOf: (e)->
		return false if not e
		return e.isChildOf @

	isChildOf: (e)->
		return false if not e
		return false if not @Owned
		return @Owned.isChildRecursive e

	moveTo: (parent)->
		@.removeFromParent()
		@.addToParent(parent)

	game: ()->
		@registry.game

	@type_property 'name'

	type: ()->
		return @Type.props.type if @Type
		return null

	parent: ()->
		return @Owned.by if @Owned
		return null

	children: ()->
		return @Owner.of if @Owner
		return []

	sibling: ()->
		return @Peer.next if @Peer
		return null

	notify: ()->
		@Viewable.notify() if @Viewable

	select : (query)->
		selector = model.Selector::parse(query)
		return selector.select @

	selector: ()->
		sel = @.toInline()
		if @Owned and @Owned.by
			sel = @Owned.by.selector() + '>' + sel
		return sel;

	toInline:()->
		ret = ''
		if @Type
			ret += @Type.props.type
			if @Type.props.name
				ret += '.' + @Type.props.name
		if @Owned and @Owned.by
			ret += '#' + @Owned.seq();
		return ret + '&' + @id

	toStr: (recursive)->
		ls = ''
		_.times recursive, ()-> ls += '\t'
		lb = '\n' + ls
		ret = @.toInline()

		if @Owned and @Owned.by
			ret += lb + '\\' + @Owned.by.toInline()
		if @Peer
			ret += lb + '>' + @Peer.next.toInline();
			ret += lb + '<' + @Peer.prev.toInline();
		if @Owner
			_.forEach @Owner.of, (one)->
				if recursive > 0
					ret += lb + '-' + one.toStr(recursive+1)
				else
					ret += lb + '-' + one.toInline()
		return ret

	postEvent: (evnt)->
		@Listeners.post(evnt)

	log: (line, vars)->
		@game().logger().log line, vars

class @Game
	constructor: (@gamecode, @module)->
		@entityRegistry = new EntityRegistry(@);
		@root = new model.Entity(@entityRegistry);

	setup: (@options)->
		@module.setup(@, @options);

	start: ()->
		return if @running
		me = @

		@runner = Fiber ()->
			avatar_names = _.values me.module.avatars(me.options)
			avatars = _.map avatar_names, (selector)-> 
				me.root.select selector
			for guy in avatars
				logger.log 'waiting for ' + guy.name + ' to get ready'
				guy.asked 
					ready : (choice)->choice

			guy.collectAll(avatars)

			try
				me.ingame = true
				me.module.run(me);
			catch e
				logger.err e, ' exception while running game...'
				me.running = false
				me.logger().finish()
				return
			
			for guy in avatars
				logger.log 'waiting for ' + guy.name + ' to confirm'
				guy.asked 
					next_game : (choice)->choice

			guy.collectAll(avatars)

			me.running = false
			me.logger().finish()
		@running = true
		@runner.run();

	yield: ()->
		return if !@running
		@running = false
		Fiber.yield();

	resume: ()->
		return if @running
		@running = true
		@runner.run();

	pauseFor: (time)->
		return if !@running
		me = @
		_.delay ()->
			me.resume()
		, time
		@.yield();

	logger: (logger)->
		@_logger = logger or @_logger or {
			log : (line, vars)->logger.log line
			score : (scores)->logger.log scores
			finish : ->  logger.log 'game finished!'
		}
		return @_logger

nthmatch = (reg, word, n)->
	match = reg.exec(word)
	return match if !match
	return match[n]

class @Selector
	constructor: (word, @anychild)->
		@type = nthmatch(/^\w+/,word,0)
		@seq  = nthmatch(/#(\w+)/,word,1)
		@id   = nthmatch(/&(\w+)/,word,1)
		@name   = nthmatch(/\.(\w+)/,word,1)

	match: (current)->
		if @type
			return false if not current.Type
			return false if (current.Type.props.type != @type)
		if @name
			return false if not current.Type
			return false if (current.Type.props.name != @name)
		if @id and (current.id != @id)
			return false
		if @seq
			return false if not current.Owned
			return false if (@seq != current.Owned.seq() + '')
		return true

	setNext: (@next)->

	selectChild: (current)->
		ret = undefined
		if current.Owner
			_.find current.Owner.of, (one)=>
				ret = @.select one
		return ret

	select : (current)->
		if @.match current
			if @next
				result = @next.selectChild current
			else
				result = current

		if not result and @anychild
			result = @.selectChild current

		return result


me = @
@Selector::parse = (str)->
	str = ' ' + str
	words = str.match /[> ][^> ]+/g
	prev = undefined
	_.forEachRight words, (one)->
		selector = new me.Selector one.slice(1), one[0] == ' '
		selector.setNext prev
		prev = selector
	return prev

class @GameEvent
	constructor: (@what, @resolve)->

	post: (@source)->
		@cancelled = false
		@conducted = false
		@source.Listeners.post @
		@source.Listeners.pop @
		return if @cancelled
		@resolve()
		@conducted = true
		@source.Listeners.post @
		@source.Listeners.pop @

class @Listener
	constructor: (@what, @handler)->
		@condition = (evnt)=>
			evnt.what == @what && !evnt.cancelled

	bindToEntity: (@entity)->
		@handler   = _.bind @handler, @entity

	handle: (evnt)->
		return false if !@condition(evnt)
		return @handler(evnt)

	only: (test)->
		prev = @condition
		test = _.bind test, @entity if @entity
		@condition = (evnt)->
			return false if !prev(evnt)
			return test(evnt)
		return @
