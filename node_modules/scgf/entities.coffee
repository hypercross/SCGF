_ = require('lodash')
Component = require('./gamecomponents')
Model = require('./gamemodel')

# helpers :
# setup block - @setup -> in class def
# setup views - @viewed or @routeView
# setup containers - @container (vp)->
# setup 
# routs vp to views and containers

Model.Entity.viewer = (callback)->
	@setup ->
		if not @Viewable
			vb = new Component.Viewable (vp)->
				view = {}
				view.place = @placing(vp)
				for viewer in vb.viewers
					_.merge(view, viewer.call(@,vp))
				return view
			vb.viewers = []
			@setComponent vb
		
		@Viewable.viewers.push callback

Model.Entity.route = (cond, callback, otherwise)->
	(vp)->
		if cond.call(@,vp)
			callback.call(@, vp) if callback
		else
			otherwise.call(@, vp) if otherwise

Model.Entity.routed = 
	isSelf : (vp)->@ is vp
	isOwned : (vp)->@ isParentOf vp
	isOwner : (vp)->@ isChildOf vp
	isCovered : (vp)->
		p = @parent()
		while p
			if p isnt vp and p.covered
				return true
			p = p.parent()
		return false

for key of Model.Entity.routed
	val = Model.Entity.routed[key]
	Model.Entity.routed[key] = (callback, otherwise)->
		Model.Entity.route val, callback, otherwise

Model.Entity.covered = ->
	@type_property 'covered', true

Model.Entity.container = (callback)->
	@type_property 'container', callback

Model.Entity.contained = (callback)->
	@type_property 'contained', callback

Model.Entity::placing = (vp)->
	if @contained then return @contained(vp)
	p = @parent()
	while p
		if p.container then return p.container(vp)
		p = p.parent()

Model.Entity.children = (map)->
	@setup ->
		for key of map
			@[key] = @spawnChild map[key], key

class @Base extends Model.Entity
	constructor: (@registry)->
		super @registry
		@.setComponent new Component.Type {}
		@.setComponent new Component.Listeners()
		@.setComponent new Component.Owner()
		@.setComponent new Component.Peer()
		@.setComponent new Component.Owned()
		@init()
	init : ->
		for func in (@setupFuncs or [])
			func.call(@)

@Base.setup = (callback)->
	if not @prototype.hasOwnProperty('setupFuncs')
		@prototype.setupFuncs = _.clone (@prototype.setupFuncs or [])
	@prototype.setupFuncs.push callback
	

@Base.markType = ->
	@type_property 'type', @name

class @Player extends @Base
	@markType
	@type_property 'status', 'idle'
	@setup ->
		@setComponent new Component.TargetFilter {}
		@setComponent new Component.Reference {}

	@property 'targets',
		get: -> @.Reference.targets

	asked: (filters)->
		return if @status isnt 'idle'
		@.TargetFilter.set filters
		@.Reference.set {}
		@status = 'playing'
		if @Viewable then @Viewable.notify()

	getAsked : -> 
		if @status isnt 'playing' then return []
		_.keys @TargetFilter.filters

	play: ()->
		return if @status is 'idle'
		while !@.TargetFilter.match(@)
			@.Reference.set {}
			@.game().yield()
		@status = 'idle'
		@TargetFilter.set {}

	collect : (players...)->
		if not players.length
			@play()
			@Viewable.notifySelf() if @Viewable
			return
		@collectAll(players)

	collectAll : (players)->
		for each in players
			each.play()
		for each in players
			if each.Viewable then each.Viewable.notifySelf()

class @Choice extends @Base
	@markType

class @Counter extends @Base
	@markType
	@setup ->
		@setComponent new Component.Counter 0, 0, 0

	@property 'current',
		get:-> @Counter.current
		set:(current)->@Counter.current = current

	@property 'max',
		get:-> @Counter.max
		set:(max)->@Counter.max = max

class @Card extends @Base
	@markType
	@setup ->
		@.setComponent new Component.TargetFilter {}

class @CardSlot extends @Base
	@markType
	@type_property 'flipped', false
	@type_property 'tapped', false

	@property 'card',
		get: -> _.first @.children()
		set: (one)->one.addToParent @

	@property 'deck',
		get: -> @.children()

	shuffle: ->
		cards = @children()
		for val,key in cards by -1
			pos = Math.floor( Math.random() * (key + 1) )
			temp = cards[pos]
			cards[pos] = cards[key]
			cards[key] = temp
		return