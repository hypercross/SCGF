_ = require('lodash')
Component = require('./gamecomponents')
Model = require('./gamemodel')

class @Base extends Model.Entity
	constructor: (@registry)->
		super @registry
		@.setComponent new Component.Type {}
		@.setComponent new Component.Listeners()
		@.setComponent new Component.Owner()
		@.setComponent new Component.Peer()
		@.setComponent new Component.Owned()
		@init()


class @Player extends @Base
	init:->
		@Type.props =
			type : 'Player'
			status : 'idle'
		@.setComponent new Component.TargetFilter {}
		@.setComponent new Component.Reference {}

	@property 'status',
		get: -> @Type.props.status
		set: (s)-> @Type.props.status = s

	@property 'targets',
		get: -> @.Reference.targets

	asked: (filters)->
		return if @status != 'idle'
		@.TargetFilter.set filters
		@.Reference.set {}
		@status = 'playing'
		if @Viewable then @Viewable.notify()

	getAsked : -> 
		_.keys @TargetFilter.filters

	play: ()->
		return if @status != 'playing'
		while !@.TargetFilter.match(@)
			@.Reference.set {}
			@.game().yield()
		@status = 'idle'
		@TargetFilter.set {}
		if @Viewable then @Viewable.notify()


@Player::collect = (players...)->
	if not players.length
		@play()
		@Viewable.notifySelf() if @Viewable
		return
	@collectAll(players)

@Player::collectAll = (players)->
	for each in players
		each.play()
	for each in players
		if each.Viewable then each.Viewable.notifySelf()

class @Choice extends @Base
	init:->
		@Type.props =
			type : 'Choice'

class @Counter extends @Base
	init:->
		@Type.props =
			type : 'Counter'
		@.setComponent new Component.Counter 0, 0, 0

	@property 'current',
		get:-> @Counter.current
		set:(current)->@Counter.current = current

	@property 'max',
		get:-> @Counter.max
		set:(max)->@Counter.max = max

class @Card extends @Base
	init:->
		@Type.props =
			type : 'Card'
		@.setComponent new Component.TargetFilter {}

class @CardSlot extends @Base
	init:->
		@Type.props =
			type : 'CardSlot'
			open : false
			flipped : false
			tapped : false

	@property 'card',
		get: -> _.first @.children()
		set: (one)->one.addToParent @

	@property 'deck',
		get: -> @.children()

	shuffle: ->
		cards = @children()
		for val,key in cards by -1
			pos = Math.floor( Math.random() * (key + 1) )
			temp = cards[pos]
			cards[pos] = cards[key]
			cards[key] = temp
		return