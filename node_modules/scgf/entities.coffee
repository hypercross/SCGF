_ = require('lodash')
Component = require('./gamecomponents')
Model = require('./gamemodel')

class @Base extends Model.Entity
	constructor: (@registry)->
		super @registry
		@.setComponent new Component.Type {}
		@.setComponent new Component.Listeners()
		@.setComponent new Component.Owner()
		@.setComponent new Component.Peer()
		@.setComponent new Component.Owned()
		@init()
	init : ->
		for func in (@setupFuncs or [])
			func.call(@)

@Base.setup = (callback)->
	@prototype.setupFuncs = @prototype.setupFuncs or []
	@prototype.setupFuncs.push callback

@Base.markType = ->
	if @type then @type += '.' + @name
	else @type_property 'type', @name

class @Player extends @Base
	@markType
	@type_property 'status', 'idle'
	@setup ->
		@setComponent new Component.TargetFilter {}
		@setComponent new Component.Reference {}

	@property 'targets',
		get: -> @.Reference.targets

	asked: (filters)->
		return if @status isnt 'idle'
		@.TargetFilter.set filters
		@.Reference.set {}
		@status = 'playing'
		if @Viewable then @Viewable.notify()

	getAsked : -> 
		if @status isnt 'playing' then return []
		_.keys @TargetFilter.filters

	play: ()->
		return if @status is 'idle'
		while !@.TargetFilter.match(@)
			@.Reference.set {}
			@.game().yield()
		@status = 'idle'
		@TargetFilter.set {}

	collect = (players...)->
		if not players.length
			@play()
			@Viewable.notifySelf() if @Viewable
			return
		@collectAll(players)

	collectAll = (players)->
		for each in players
			each.play()
		for each in players
			if each.Viewable then each.Viewable.notifySelf()

class @Choice extends @Base
	@markType

class @Counter extends @Base
	@markType
	@setup ->
		@setComponent new Component.Counter 0, 0, 0

	@property 'current',
		get:-> @Counter.current
		set:(current)->@Counter.current = current

	@property 'max',
		get:-> @Counter.max
		set:(max)->@Counter.max = max

class @Card extends @Base
	@markType
	@setup ->
		@.setComponent new Component.TargetFilter {}

class @CardSlot extends @Base
	@markType
	@type_property 'flipped', false
	@type_property 'tapped', false

	@property 'card',
		get: -> _.first @.children()
		set: (one)->one.addToParent @

	@property 'deck',
		get: -> @.children()

	shuffle: ->
		cards = @children()
		for val,key in cards by -1
			pos = Math.floor( Math.random() * (key + 1) )
			temp = cards[pos]
			cards[pos] = cards[key]
			cards[key] = temp
		return