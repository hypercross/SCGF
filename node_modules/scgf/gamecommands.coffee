Component = require('./gamecomponents')
Model = require('./gamemodel')
Entity = require('./entities')
Viewer = require './gameviewer'
_ = require('lodash')
logger = require('./logger')

trim = (str)->str.replace(/[\n\r]+$/,'')

@handle = (game, args)->
	cmd_name = trim(args._[0])
	if not cmd_name
		return
	cmd = cmds[cmd_name]
	if cmd
		cmd(game, args)
	else logger.log 'no such cmd called "' + cmd_name + '"'

addToParent = (child, parent)->
	parent = child.game().root if not parent
	if !parent.Owner
		parent.setComponent new Component.Owner()
	child.setComponent new Component.Peer (
		_.last parent.Owner.of
	)
	child.setComponent new Component.Owned parent;
	child.Peer.claim();
	child.Owned.claim();

removeFromParent = (child)->
	parent = child.Owned.by
	_.remove parent.Owner.of, (one)->one == child
	child.Peer.prev.Peer.next = child.Peer.next
	child.Peer.next.Peer.prev = child.Peer.prev
	child.Owned.by = null

cmds = {
	act : (game, arg)->
		player = game.root.select arg._[1]
		action = trim(arg._[2])
		targets = _.map arg._.slice(3),(one)->
			game.root.select trim(one)

		player.targets[action] = targets

	play : (game, arg)->
		player = arg._[1]
		target = arg._[2]
		return if not player or not target

		player = game.root.select player
		return if player.status != 'playing'
		target = player.select target
		player.Reference.targets.play = [target]
		game.resume()

	point : (game, arg)->
		return if not arg.target
		return if not arg.pointer
		_.forEach arg._, (one)->
			return if one == 'point'
			entity = game.root.select one
			return if not entity
			if not entity.Reference
				entity.setComponent new Component.Reference arg {}
			entity.Reference.targets[arg.pointer] =
				[game.root.select arg.target]


	spawn : (game, arg)->
		if not arg.type
			arg.type = 'Default'
		e = game.entityRegistry.spawnEntityByType arg.type

		if not arg.parent
			arg.parent = '&1'
		parent = Model.Selector::parse(arg.parent).select(game.root)
		if not parent
			parent = game.root

		e.setComponent new Component.Type {} if not e.Type
		e.Type.props.type = arg.type
		e.Type.props.name = arg.name
		addToParent(e, parent)
		logger.log 'spawned ' + e.constructor.name
		return e

	exile : (game, arg)->
		_.forEach arg._, (one)->
			return if one == 'exile'
			thing = Model.Selector::parse(one).select(game.root)
			if thing
				removeFromParent(thing)
				thing.remove()

	move : (game, arg)->
		if not arg.parent
			arg.parent = '&1'
		parent = Model.Selector::parse(arg.parent).select(game.root)
		if not parent
			parent = game.root

		_.forEach arg._, (one)->
			return if one == 'move'
			thing = Model.Selector::parse(one).select(game.root)
			if thing
				removeFromParent(thing)
				addToParent thing, parent
	counter : (game, arg)->
		#  get/set/add on counter
	view : (game, arg)->
		# shows the game viewed by a viewpoint in a readable way
		if(arg.game)
			logger.log game
		_.forEach arg._, (one)->
			one = trim(one)
			return if one == 'view'
			selector = Model.Selector::parse(one)
			logger.log 'select: "' + one + '"'
			ret = selector.select(game.root)
			if ret
				ret = ret.toStr(arg.r * 1)
			logger.log ret
	setup : (game, arg)->
		game.setup(arg)
	start : (game, arg)->
		game.start()
	resume : (game, arg)->
		game.resume()
	snap : (game, arg)->
		logger.log Viewer.snapshot(game, game.root.select arg._[1])
	watch: (game, arg)->
		vp = game.root.select arg._[1]
		Viewer.watchby vp, (type, thing)->
			logger.log type
			logger.log thing
	unwatch: (game, arg)->
		vp = game.root.select arg._[1]
		Viewer.unwatchby vp
}
