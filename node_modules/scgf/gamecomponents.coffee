_ = require('lodash');

#
# Components
#

class Component
	setEntity: (@entity)->
		@entity[@constructor.name] = @;
	onDelete: ()->

#
# Atomic components
#

# for target matching
# applys on a map of targets from @Reference
# i.e a skill may say okay this card can target
# someone not allowed otherwise
class @TargetFilter extends Component
	constructor: (@filters) ->

	dismatch: (refs) ->
		!@match(refs)

	match: (target) ->
		match = false
		for key,choice of target.targets
			if @filters[key](choice)
				match = true 
			else
				delete target.targets[key]
		return match

	set: (@filters)->

# for type matching
# can be used for TargetFilter
# or simply identifying the entity in general
class @Type extends Component
	constructor: (@props) ->

# for pointing at specific entities in general
# can be used for player choices
class @Reference extends Component
	constructor: (@targets)->

	set: (@targets)->

# for entity relationship
# ideally all entities must be in a tree
class @Owner extends Component
	constructor: (@of) ->
		if !@of
			@of = [];

	# make sure all children's Owned points here
	claim: ()->
		me = @
		_.forEach @of, (one)->
			one.Owned.by = me;

	isOwnerRecursive: (one)->
		return one.Owned.isChildRecursive(@entity)

class @Owned extends Component
	constructor: (@by)->

	# make sure parent knows me
	claim: ()->
		me = @
		if (_.find @by.Owner.of, (one)-> one == me)
			return
		@by.Owner.of.push(me.entity);

	isChildRecursive: (one)->
		return true if @by == one
		return false if !@by
		return false if !@by.Owned
		return @by.Owned.isChildRecursive(one)

	seq: ()->
		return 0 if not @by
		return 0 if not @by.Owner
		return 0 if not @by.Owner.of
		_.findIndex @by.Owner.of, @entity


class @Peer extends Component
	constructor: (@prev) ->
		if @prev
			@next = @prev.Peer.next;

	setEntity: (@entity)->
		super(@entity)
		if !@prev
			@prev = @next = @entity

	appendTo: (@prev)->
		if @prev
			@next = @prev.Peer.next;
		else
			@prev = @next = @entity

	# make sure peer knows me
	claim: ()->
		return if not @prev
		@prev.Peer.next = @entity;
		@next.Peer.prev = @entity;

	isPeer: (one)->
		next = @entity;
		while true
			return true if next == one;
			next = next.Peer.next;
			return false if next == @entity;

# for event system
# each entity must have one for its children to receive events
class @Listeners extends Component
	constructor: (@list) ->
		@handled_stack = []
		if !@list
			@list = {}

	add: (key, listener)->
		@list[key] = listener
		listener.bindToEntity @entity
		return listener

	post: (e)->
		return if _.last(@handled_stack) == e
		return if e.cancelled
		@handled_stack.push e

		if @entity.Owner
			_.forEach @entity.Owner.of, (one)->
				one.Listeners.post(e) if one.Listeners

		_.forEach @list, (one)->
			one.handle(e);

		if @entity.Peer and @entity.Peer.next.Listeners
			@entity.Peer.next.Listeners.post(e)

		if @entity.Owned and @entity.Owned.by.Listeners
			@entity.Owned.by.Listeners.post(e)

	pop: (e)->
		return if _.last(@handled_stack) != e
		@handled_stack.pop()

		if @entity.Owner
			_.forEach @entity.Owner.of, (one)->
				one.Listeners.pop(e) if one.Listeners

		if @entity.Peer and @entity.Peer.next.Listeners
			@entity.Peer.next.Listeners.pop(e)

		if @entity.Owned and @entity.Owned.by.Listeners
			@entity.Owned.by.Listeners.pop(e)

# for numerical counter in general
class @Counter extends Component
	constructor: (@min, @max, @current)->

# for view rendering in general
class @Viewable extends Component
	constructor: (@renderer)->
		@history = {}

	render: (viewpoint)->
		view = @renderer(viewpoint)
		record = @history[viewpoint.id] or {}
		if view.place isnt record.current
			record.from = record.current
			record.current = view.place
		@history[viewpoint.id] = record
		view.from = record.from
		view.id = @entity.id
		return view

	fx: (effector)->
		_.forEach @entity.game().watchers or {}, (watch)=>
			watch.handler 'fx', effector.call(@,watch.watcher)
		return

	notify: ()->
		_.forEach @entity.game().watchers or {}, (watch)=>
			@notifyOne watch
		return

	notifySelf: ()->
		watch = (@entity.game().watchers or {})[@entity.id]
		return if not watch
		@notifyOne watch

	notifyOne: (watch)->
		view = @render watch.watcher
		watch.handler 'game', view