@Commands = require './gamecommands'
@Entity = require './entities'
@Model = require './gamemodel'
@Viewer = require './gameviewer'
@Component = require './gamecomponents'
logger = require './logger'
_ = require 'lodash'
me = @

defineEntity = (game, type)->
	game.entityRegistry.addPrototype type

spawnLayoutUnder = (game, layout, parent)->
	_.forEach layout, (val, key)->
		logger.log 'under ' + parent.selector()
		if typeof val == 'function'
			if !game.entityRegistry[val.name]
				defineEntity game, val
			e = me.Commands.handle game,
				_ : ['spawn']
				type : val.name
				name : key
				parent : parent.selector()
		else
			e = me.Commands.handle game,
				_ : ['spawn']
				type : 'container'
				name : key
				parent : parent.selector()
			spawnLayoutUnder game, val, e
			

@spawnLayout = (game, layout)->
	spawnLayoutUnder game, layout, game.root

# helpers :
# setup block - @setup -> in class def
# setup views - @viewed or @routeView
# setup containers - @container (vp)->
# setup 
# routs vp to views and containers

@Model.Entity.viewer = (callback)->
	if not @prototype.Viewable then
		vb = new Loader.Component.Viewable (vp)->
			view = {}
			view.place = @placing(vp)
			for viewer in vb.viewers
				_.merge(view, viewer.call(@,vp))
			return view
		vb.viewers = []
		@prototype.setComponent vb
	
	@prototype.Viewable.viewers.push callback

@Model.Entity.route = (cond, callback, otherwise)->
	(vp)->
		if cond.call(@,vp)
			callback.call(@, vp) if callback
		else
			otherwise.call(@, vp) if otherwise

@Model.Entity.routed = 
	isSelf : (vp)->@ is vp
	isOwned : (vp)->@ isParentOf vp
	isOwner : (vp)->@ isChildOf vp
	isCovered : (vp)->
		p = @parent()
		while p
			if p isnt vp and p.covered
				return true
			p = p.parent()
		return false

for key of @Model.Entity.routed
	val = @Model.Entity.routed[key]
	@Model.Entity.routed[key] = (callback, otherwise)->
		@Model.Entity.route val, callback, otherwise

@Model.Entity.covered = ->
	@type_property 'covered', true

@Model.Entity.container = (callback)->
	@type_property 'container', callback

@Model.Entity.contained = (callback)->
	@type_property 'contained', callback

@Model.Entity::placing = (vp)->
	if @contained then return @contained(vp)
	p = @parent()
	while p
		if p.container then return p.container(vp)
		p = p.parent()

@Model.Entity.children = (map)->
	@setup ->
		for key of map
			@[key] = @spawnChild map[key], key